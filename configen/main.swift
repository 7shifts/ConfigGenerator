//
//  main.swift
//  configen
//
//  Created by Sam Dods on 29/09/2015.
//  Copyright Â© 2015 The App Business. All rights reserved.
//

import Foundation

extension String {
  var trimmed: String {
    return (self as NSString).stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
  }
}

let arguments = Process.arguments
guard arguments.count == 5 else {
  fatalError("usage: \(arguments.first!) <inputPlistFilePath> <inputHintsFilePath> <outputClassName> <outputClassDirectory>")
}

let inputPlistFilePath = arguments[1]
let inputHintsFilePath = arguments[2]
let outputClassName = arguments[3]
let outputClassDirectory = arguments[4]
let outputClassHeaderName = "\(outputClassDirectory)/\(outputClassName).h"
let outputClassImplementationName = "\(outputClassDirectory)/\(outputClassName).m"

guard let data = NSData(contentsOfFile: inputPlistFilePath) else {
  fatalError("No data at path: \(inputPlistFilePath)")
}

guard let plistDictionary = (try? NSPropertyListSerialization.propertyListWithData(data, options: .Immutable, format: nil)) as? Dictionary<String, AnyObject> else {
  fatalError()
}

guard let hintsString = try? NSString(contentsOfFile: inputHintsFilePath, encoding: NSUTF8StringEncoding) else {
  fatalError("No data at path: \(inputHintsFilePath)")
}

var hintsDictionary = Dictionary<String, String>()

let hintLines = hintsString.componentsSeparatedByCharactersInSet(NSCharacterSet.newlineCharacterSet())
for hintLine in hintLines where hintLine.trimmed.characters.count > 0 {
  let hints = hintLine.componentsSeparatedByCharactersInSet(NSCharacterSet(charactersInString: ":")).map { $0.trimmed }
  guard hints.count == 2 else {
    fatalError("Expected \"variableName : Type\", instead of \"\(hintLine)\"")
  }
  let (variableName, type) = (hints[0], hints[1])
  hintsDictionary[variableName] = type
}

func methodDeclarationForVariableName(variableName: String, type: String) -> String {
  var line = ""
  
  switch (type) {
  case ("Double"), ("Int"):
    line += "+ (NSNumber *)\(variableName)"
    
  case ("String"):
    line += "+ (NSString *)\(variableName)"
    
  case ("Bool"):
    line += "+ (BOOL)\(variableName)"
    
  case ("NSURL"):
    line += "+ (NSURL *)\(variableName)"
    
  default:
    fatalError("Unknown type: \(type)")
  }
  
  return line
}

func methodImplementationForVariableName(variableName: String, type: String) -> String {
  
  guard let value = plistDictionary[variableName] else {
    fatalError("No configuration setting for variable name: \(variableName)")
  }
  
  let token = "$$"
  var line = methodDeclarationForVariableName(variableName, type: type) + "\n{\n  return \(token);\n}"
  
  func replaceTokenWith(string: String) {
    line = line.stringByReplacingOccurrencesOfString(token, withString: string)
  }
  
  switch (type) {
  case ("Double"), ("Int"):
    replaceTokenWith("@\(value)")
    
  case ("String"):
    replaceTokenWith("@\"\(value)\"")
    
  case ("Bool"):
    let boolString = value as! Bool ? "YES" : "NO"
    replaceTokenWith("\(boolString)")
    
  case ("NSURL"):
    let url = NSURL(string: value as! String)!
    guard url.host != nil else {
      fatalError("Found URL without host: \(url) for setting: \(variableName)")
    }
    replaceTokenWith("[NSURL URLWithString:@\"\(value)\"]")
    
  default:
    fatalError("Unknown type: \(type)")
  }
  
  return line
}

var headerOutputString = ""
var implementationOutputString = ""

for (variableName, type) in hintsDictionary {
  var headerLine = methodDeclarationForVariableName(variableName, type: type)
  headerOutputString.appendContentsOf("\n" + headerLine + ";" + "\n")
  
  var implementationLine = methodImplementationForVariableName(variableName, type: type)
  implementationOutputString.appendContentsOf("\n" + implementationLine + "\n")
}


let appName = (arguments.first! as NSString).lastPathComponent
let headerComment = "// auto-generated by \(appName)\n\n"
let foundationImport = "#import <Foundation/Foundation.h>\n\n"
headerOutputString = "\(headerComment)\(foundationImport)@interface \(outputClassName) : NSObject \n\(headerOutputString)\n@end\n"
let headerImport = "#import \"\(outputClassName).h\""
implementationOutputString = "\(headerComment)\(headerImport)\n\n@implementation \(outputClassName) \n\(implementationOutputString)\n@end\n"

do {
  try headerOutputString.writeToFile(outputClassHeaderName, atomically: true, encoding: NSUTF8StringEncoding)
}
catch {
  fatalError("Failed to write to file at path \(outputClassHeaderName)")
}

do {
  try implementationOutputString.writeToFile(outputClassImplementationName, atomically: true, encoding: NSUTF8StringEncoding)
}
catch {
  fatalError("Failed to write to file at path \(outputClassImplementationName)")
}

